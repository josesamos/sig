[["index.html", "Cartografía con R Sistemas de Información Geográfica 1 Introducción", " Cartografía con R Sistemas de Información Geográfica José Samos Jiménez (jsamos@ugr.es) Dpto. de Lenguajes y Sistemas Informáticos Universidad de Granada Curso 2024-2025 Citar y Licencia: https://doi.org/10.6084/m9.figshare.26965558.v2 Vídeo (Introducción a R): https://youtu.be/j5Oxri134xQ Vídeo (Cartografía con R): https://youtu.be/0WkOijfG8BQ 1 Introducción R1 es un proyecto de software libre, se basa en el lenguaje S, desarrollado originalmente en Bell Laboratories en los años 70 y 80 del siglo pasado. R como tal fue desarrollado en la University of Auckland, New Zealand. Comenzó como proyecto en 1992 y la primera versión estable se lanzó en 2000. Funciona sobre Linux, Unix, Mac OSX, Windows y Android. Como principales características se puede remarcar la facilitad que presenta para trabajar con estructuras de datos y con gráficos, y el repositorio de paquetes disponibles para su uso. En lugar de trabajar directamente sobre R, usaremos RStudio2, entorno de desarrollo integrado (IDE) especialmente pensado para R que permite ejecución paso a paso, visualización del entorno, acceso a la ayuda, formateo del código, definición de proyectos y directorio de trabajo, entre otras funcionalidades. Objetivos Repasar conceptos sobre Información Geográfica explicados en clase de Teoría, materializados en un SIG concreto. Introducir R mediante ejemplos y utilizarlo como SIG. No es una introducción exhaustiva sino un primer contacto; se pondrá en práctica: Estructuras de datos. Control de flujo. Funciones. Plots básicos. Paquetes. Visualización de capas. Crear un mapa temático. Las actividades propuestas se basan principalmente en Lovelace, Nowosad, and Muenchow (2019), Brundsdon and Comber (2019) y Matloff (2011). Nota especial para quien trabaje sobre Ubuntu Antes de realizar esta actividad, es conveniente instalar los paquetes siguientes: sf sp OpenStreetMap readxl tmap En Windows se instalan bastante rápido, pero en Ubuntu hay que compilarlos y puede tardar mucho tiempo. Referencias Brundsdon, Chris, and Lex Comber. 2019. An Introduction to R for Spatial Analysis &amp; Mapping. 2nd ed. SAGE. Lovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019. Geocomputarion with R. 2nd ed. CRC Press. https://r.geocompx.org/. Matloff, Norman. 2011. The Art of R Programming: A Tour of Statistical Software Design. no starch press. https://www.r-project.org/↩︎ https://www.rstudio.com/↩︎ "],["intro-r-mediante-ejemplos.html", "2 Introducción a R mediante ejemplos 2.1 Entorno de trabajo 2.2 Funcionamiento general 2.3 Estructuras de datos 2.4 Control de flujo 2.5 Funciones 2.6 Leer y escribir estructuras de datos 2.7 Plots básicos 2.8 Paquetes", " 2 Introducción a R mediante ejemplos Vídeo: https://youtu.be/j5Oxri134xQ A continuación, se van a introducir distintos aspectos de R mediante ejemplos. No pretende ser un resumen de R sino un repaso de aspectos que se van a utilizar al tratar información geográfica. Se pueden encontrar verdaderas introducciones a R, por ejemplo, en: W. J. Owen: The R Guide3. G. Rodríguez: Introducing R4. P. Torfs, C. Braue: A (very) short introduction to R5. W. N. Venables, D. M. Smith and the R Core Team: An Introduction to R6. The R Guide de W. J. Owen es posiblemente la más conocida. 2.1 Entorno de trabajo Figura 2.1: Crear un nuevo script. Trabajaremos con R desde RStudio: iniciamos RStudio que a su vez inicia R. La manera más inmediata de realizar un desarrollo sencillo en R es creando un nuevo archivo de R (un script)7, como se muestra en la figura 2.1, pulsando sobre el icono New file y seleccionando la opción R Script. Figura 2.2: Ejecutar un nuevo script. La ventana de RStudio tiene cuatro zonas (figura 2.2). La parte superior izquierda corresponde al archivo R que acabamos de crear. En esta zona iremos escribiendo el código R que desarrollemos (en este caso, copiando-y-pegando el de las figuras siguientes). Para ejecutar una línea de código, situamos el cursor en cualquier parte de la línea y pulsamos sobre el botón Run (figura 2.2). El cursor se sitúa en la línea siguiente para que podamos ejecutarla al volver a pulsar sobre el mismo botón8. En la ventana inferior izquierda, Console, se muestran las instrucciones que se envían a R y el resultado que este devuelve. Si se ha creado o modificado una variable, el resultado se puede ver en la ventana de la parte superior derecha, Environment. 2.2 Funcionamiento general 2.2.1 Asignación y operaciones aritméticas A continuación, se muestran dos formas de asignación (= y &lt;-). En la mayoría de la situaciones resultan equivalentes; puede haber diferencias dependiendo del ámbito de las variables. En las guías de estilo de R se recomienda usar una de ellas pero siempre la misma. Al poner una asignación entre paréntesis adicionalmente se presenta el resultado obtenido. x &lt;- 3 y &lt;- 2 x + y z &lt;- x + y z (z &lt;- x + y) x = 3 y = 2 x + y z = x + y z (z = x + y) 2.2.2 Constantes y funciones En R se pueden usar funciones y constantes predefinidas. Obtenemos ayuda sobre lo que hace una función ejecutando la línea con ? y el nombre de la función. La ayuda aparecerá en la zona inferior derecha de la ventana, se activará automáticamente la pestaña Help. 2 * pi * z sqrt(z) ?sqrt Pulsando sobre el botón Show in new window de la zona de ayuda de la ventana, se abre la ayuda en una nueva ventana, para poder leerla más fácilmente. 2.2.3 Definición y operaciones matemáticas con vectores A continuación, se define un vector numérico y se realizan operaciones con él. Observa las diferencias entre la clase de los resultados que se obtienen (número o vector). r1 &lt;- c(2, 3, 3, 5, 2, 1, 4) 2 * pi * r1 r2 &lt;- 1:5 2 * pi * r2 sum(r1) sqrt(r1) round(sqrt(r1), 2) r1^2 r1 + 1 r1 * 2 2.2.4 Selección de elementos en un vector Los elementos de un vector se pueden seleccionar mediante diversos métodos. A continuación, se muestran algunos de ellos: un vector de índices, un vector de índices de los elementos que no se incluyen en el resultado, un vector de booleanos. En este último caso, se muestra cómo definirlo explícitamente o bien obtenerlo como resultado de una operación de comparación. r1[2:4] r1[c(1,3,6)] 1:length(r1) r1 &gt; 3 r1[r1 &gt; 3] s &lt;- c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE) r1[s] s1 &lt;- !s r1[s1] s2 &lt;- r1 &gt; 3 n &lt;- c(&quot;María&quot;, &quot;Carmen&quot;, &quot;Guillermo&quot;, &quot;Ana&quot;, &quot;Sergio&quot;, &quot;Lara&quot;, &quot;Lucas&quot;) n[s2] n[2] n[-2] n[-(2:4)] 2.2.5 Unión de vectores Mediante la función c() se combinan elementos para formar un vector. Como se muestra a continuación, los elementos pueden ser también vectores. Como todos los elementos de un vector han de ser del mismo tipo, el tipo del resultado ha de ser el más general de los tipos de los vectores implicados, entendiendo por este, el tipo al que se puedan transformar el resto de tipos sin perder información. (n2 &lt;- c(n, n)) (n3 &lt;- c(n, r1, s)) (n4 &lt;- c(r1, s, n)) (n5 &lt;- c(r1, s)) 2.3 Estructuras de datos 2.3.1 Vector A continuación, podemos ver los valores y tamaño por defecto de un vector cuando se crea, según los parámetros que indiquemos o si lo creamos implícitamente; también se muestran distintas posibilidades que ofrece la función rep() para crear vectores. (v1 &lt;- vector(mode=&quot;numeric&quot;, length = 7)) (v2 &lt;- vector(length = 7)) (v3 &lt;- vector(mode=&quot;numeric&quot;)) v3[4] &lt;- 1 v3 rep(0, times = 7) rep(1:4, times = 2) rep(1:4, each = 2) rep(1:4, times = c(2,1,3,2)) rep(1:4, each = 2, len = 6) rep(1:4, each = 2, times = 3) 2.3.2 Data frame Podemos crear un data frame a partir de vectores, a los que les asignamos nombre dentro de la estructura: son las columnas del data frame, como se muestra a continuación. Un data frame puede tener tantas columnas como deseemos (no necesariamente dos como en los ejemplos siguientes). Podemos acceder a las columnas mediante su nombre o bien su posición en la estructura. Los vectores que forman las columnas pueden no tener el mismo número de elementos, siempre que el mayor sea múltipo del resto. n r1 (d &lt;- data.frame(persona = n, puntos = r1)) d$persona d$puntos colnames(d) colnames(d) &lt;- c(&quot;person&quot;, &quot;score&quot;) d$score d[, &quot;score&quot;] d[, 2] d[2,] d[2, 2] d[2:5, ] d[-c(1,6,7), ] d[2:5, 2] n2 (d2 &lt;- data.frame(persona = n2, puntos = r1)) (d3 &lt;- data.frame(persona = n2, puntos = c(1, 2))) # Error: arguments imply differing number of rows: 14, 3 # (d4 &lt;- data.frame(persona = n2, puntos = c(1, 2, 3))) 2.3.3 Matrix A continuación, se muestran distintas formas de definir una matriz (matrix), según sus dimensiones y el orden de creación (por filas o por columnas). Asimismo, podemos ver cómo se le pueden asignar nombres a las filas y columnas de la matriz, y acceder a los elementos por nombre o por posición. matrix(ncol = 2, nrow = 0) matrix(ncol = 2, nrow = 1) matrix(1:6) matrix(1:6, ncol = 2) matrix(1:6, ncol = 2, byrow = TRUE) (m &lt;- matrix(1:6, nrow = 3)) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;) rownames(m) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) m m[, 2] m[, &quot;b&quot;] m[2, ] m[&quot;y&quot;, ] m[&quot;y&quot;, 2] 2.3.4 Factor Cuando incluimos un vector de strings en un data frame, si incluimos el parámetro stringsAsFactors = TRUE, lo trata como un factor: considera los valores distintos (levels) y representa los datos en función de esos valores, como se muestra a continuación. Por defecto se trata como string (el valor por defecto del parámetro es stringsAsFactors = FALSE). Si definimos explícitamente los niveles a tener en cuenta en el factor, no se consideran los valores no incluidos entre los niveles. (d2 &lt;- data.frame(persona = n2, puntos = r1)) d2$persona (d3 &lt;- data.frame(persona = n2, puntos = r1, stringsAsFactors = TRUE)) d3$persona (f &lt;- factor(n2)) (f2 &lt;- factor(n2, levels = c(&quot;Lara&quot;, &quot;Ana&quot;))) 2.3.5 List Una lista (list) puede estar compuesta por elementos de distinto tipo y número de instancias, como se muestra a continuación. A los elementos se les puede asignar nombres y podemos acceder a ellos por nombre o por posición. (l &lt;- list(n2, m, d, 2)) l[[2]][1,] (l2 &lt;- list(nombres = n2, matriz = m, df = d)) l2[[2]] l2$matriz l2[[&quot;matriz&quot;]] 2.4 Control de flujo 2.4.1 Iteraciones A continuación, se muestran distintas formas de iterar sobre una estructura de ejemplo. También se puede ver que se puede imprimir sin necesidad de iterar por ella. for (nombre in n) { print(nombre) } for (i in 1:length(n)) { print(n[i]) } i &lt;- 1 while (i &lt;= length(n)) { print(n[i]) i &lt;- i + 1 } print(n) 2.4.2 Ejecución condicional En lo que se refiere a la ejecución condicional, además de la construcción if-else, común en los lenguajes de programación, es destacable la posibilidad de tratar todos los elementos de un vector directamente mediante ifelse, como se muestra a continuación. a &lt;- 2 if (a == 3) { print(a) } else { print(a*2) } ifelse(n == &#39;Ana&#39;, 1, 0) ifelse(r1 &lt; 2, 0, 1) 2.5 Funciones 2.5.1 Función con parámetros con valores por defecto A continuación, se muestra la definición y uso de una función con un parámetro con valor por defecto. Las funciones devuelven el último valor calculado, se puede indicar explícitamente el resultado mediante return() aunque no lo recomiendan las guías de estilo de R salvo que no sea la última instrucción de la función. f &lt;- function(a, b = 1) { a + b } f(2) f(2, 3) 2.5.2 Función a la que se pasa otra función como parámetro Se pueden definir funciones a las que se pasa como parámetro otra función y, dentro de la función, invocar a la función que se ha pasado, como se hace a continuación. g &lt;- function(a) { return(a + 1) } g(2) h &lt;- function(k, a) { k(a) } h(g, 2) h(f, 2) 2.5.3 Ámbito de las variables Desde una función se puede acceder a una variable global pero esta no se puede modificar desde la función, ni directamente, ni pásandola como parámetro, como se muestra a continuación. a &lt;- 2 p &lt;- function(b) { b &lt;- b + a a &lt;- 1 return(b) } p(a) a 2.6 Leer y escribir estructuras de datos 2.6.1 Guardar un data frame en un archivo y volverlo a leer Cuando trabajamos con archivos, es práctico configurar la carpeta de trabajo mediante setwd()9 porque, de esta forma, basta con indicar el nombre del archivo. También se puede observar en el fragmento de código siguiente que, al escribir y leer un data frame, la estructura que se lee no coincide exactamente con la escrita: se le ha añadido una columna adicional con el número de línea. Si abrimos el archivo generado, se puede comprobar que la columna se ha generado al guardar los datos. Si queremos que no se almacene el número de fila lo tendremos que indicar al guardar el data frame, se hace mediante el parámetro row.names. Se puede observar que la clase del resultado que obtenemos es un data frame. getwd() # setwd(&quot;sig/datos&quot;) d write.csv(d, &quot;marcador.csv&quot;) (res &lt;- read.csv(&quot;marcador.csv&quot;, header = TRUE, sep = &quot;,&quot;)) res$person class(res) 2.6.2 Guardar y leer un data frame, e interperetar strings como factores A continuación, escribe y lee el data frame con el mismo número de columnas. También se indica que interprete como factores los valores de los strings que lea. write.csv(d, &quot;marcador.csv&quot;, row.names = FALSE) (res &lt;- read.csv(&quot;marcador.csv&quot;, header = TRUE, sep = &quot;,&quot;, stringsAsFactors = TRUE)) res$person 2.6.3 Guardar y leer una matriz En el caso de guardar y leer una matriz, si le hemos dado nombre a las filas, nos interesa guardar sus nombres y recuperarlos al leer los datos. Se puede observar que leemos un data frame, pero lo podemos transformar en una matriz eliminando la columna correspondiente al nombre de las filas y haciendo una conversión de tipos. m write.csv(m, &quot;matriz.csv&quot;) (mat &lt;- read.csv(&quot;matriz.csv&quot;, header = TRUE, sep = &quot;,&quot;)) class(mat) rownames(mat) &lt;- mat[, 1] (mat &lt;- as.matrix(mat[, -1])) class(mat) 2.7 Plots básicos 2.7.1 Diagrama de dispersión e histograma La función genérica para representar gráficamente objetos en R es plot(). Como se muestra a continuación, en este caso, estamos representando puntos. La forma de representación de los puntos se determina mediante el parámetro pch10. También podemos utilizar otras funciones para obtener otros tipos de representación, como hist(), a continuación. x1 &lt;- rnorm(100) y1 &lt;- rnorm(100) plot(x1, y1, pch=16, col=&#39;blue&#39;) hist(x1) 2.7.2 Línea con puntos A continuación, se muestra cómo usar la misma función plot() para representar los puntos unidos mediante una línea. También se pueden representar puntos en el mismo gráfico. x2 &lt;- seq(0, 2*pi, len=100) y2 &lt;- sin(x2) plot(x2, y2, type=&#39;l&#39;, lwd=2, col=&#39;darkgreen&#39;, ylim=c(-1.2, 1.2)) y2r &lt;- y2 + rnorm(100, 0, 0.1) points(x2, y2r, pch=&#39;.&#39;, col=&#39;darkred&#39;) 2.7.3 Polígonos y plots múltiples En el ejemplo siguiente, se divide la superficie de representación en dos partes mediante la función par(), una fila y dos columnas para poder mostrar conjuntamente dos figuras. Posteriormente, cuando se ha hecho la representación, se vuelve a dejar una sola columna mediante la misma función. En las dos representaciones se muestran los mismos datos, la diferencia entre ellas se produce por los parámetros asp (para mantener la proporcionalidad de la figura) y type (para no representar los datos propiamente dichos, sino establecer el área de representación que requieren). # x2 &lt;- seq(0, 2*pi, len=100) # y2 &lt;- sin(x2) y3 &lt;- cos(x2) par(mfrow=c(1,2)) plot(y2, y3, asp=1) polygon(y2, y3, col=&#39;lightgreen&#39;) plot(y2, y3, type=&#39;n&#39;) polygon(y2, y3, col=&#39;lightgreen&#39;) par(mfrow=c(1,1)) 2.7.4 Rectángulos, colores y transparencia En el siguiente ejemplo, se muestra el uso de colores y la posibilidad de definir niveles de transparencia: se define mediante el cuarto parámetro de la función rgb(), que es opcional. par(mfrow=c(1,2)) plot(c(-1.5,1.5),c(-1.5,1.5),asp=1, type=&#39;n&#39;) rect(-0.5,-0.5,0.5,0.5, border=NA, col=rgb(0,0.5,0.5)) rect(0,0,1,1, col=rgb(1,0.5,0.5)) plot(c(-1.5,1.5),c(-1.5,1.5),asp=1, type=&#39;n&#39;) rect(-0.5,-0.5,0.5,0.5, border=NA, col=rgb(0,0.5,0.5,0.7)) rect(0,0,1,1, col=rgb(1,0.5,0.5,0.7)) par(mfrow=c(1,1)) 2.8 Paquetes Figura 2.3: Instalar package. La funcionalidad básica de R se amplía mediante paquetes (packages) que podemos añadir a la instalación. Los paquetes instalados se pueden ver desde la pestaña Packages de la zona inferior derecha de la ventana (figura 2.3). Si necesitamos usar un paquete que no está instalado aún, pulsando sobre el botón Install podemos indicar que se instale. Figura 2.4: Acceso a la información de un package. Un paquete puede contener funciones y datos. Podemos acceder a la información de un paquete pulsando sobre el primer icono que aparece a la derecha de su nombre y versión, en la pestaña Packages (figura 2.4). Para utilizar el contenido de un paquete fácilmente, tenemos que indicar que se cargue, esto se hace mediante la función library(). https://cran.r-project.org/doc/contrib/Owen-TheRGuide.pdf↩︎ http://data.princeton.edu/R/introducingR.pdf↩︎ https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf↩︎ https://cran.r-project.org/doc/manuals/R-intro.pdf↩︎ Es recomendable agrupar los scripts que desarrollemos en un proyecto. Antes de crear el primer script crearemos el proyecto desde File &gt; New Project.↩︎ Si seleccionamos varias líneas, al pulsar sobre el botón Run, se ejecutan todas. En esta actividad, nos interesará ejecutar línea a línea.↩︎ Actualiza el parámetro que se pasa a esta función en el fragmento de código siguiente con tu carpeta de trabajo.↩︎ En https://www.statmethods.net/advgraphs/parameters.html se pueden consultar los posibles valores que puede tomar este parámetro y el resultado obtenido en cada caso. También hay información de otros parámetros para definir el estilo de las líneas o los colores.↩︎ "],["representación-de-capas.html", "3 Representación de capas 3.1 Obtención de los datos 3.2 Leer capas 3.3 Representar capas 3.4 Cambiar el color y otros elementos de una capa 3.5 Importar una imagen desde la Web", " 3 Representación de capas En el resto del documento, basándonos en las operaciones básicas presentadas en los ejemplos anteriores, vamos a usar R como un SIG. Vídeo: https://youtu.be/0WkOijfG8BQ 3.1 Obtención de los datos Usaremos los mismos datos que hemos usado con QGIS. En QGIS, cuando se añaden nuevos campos, se modifican las tablas de atributos de las capas en los archivos de estas. Por este motivo, aunque se hayan obtenido los datos para QGIS, es recomendable usar otra carpeta de trabajo y obtener de nuevo las capas. En el caso del archivo Excel descargado del INE, podemos generar de nuevo la tabla de datos o copiar el archivo de la tabla y eliminar la columna adicional añadida en QGIS. 3.2 Leer capas En el ejemplo siguiente, comenzamos cargando el paquete sf. Hay muchos paquetes para trabajar con información geográfica. El paquete sp se usaba frecuentemente, sf está ocupando su lugar. Muchos paquetes, inicialmente basados en sp, se han adaptado a sf. Todavía quedan paquetes basados en sp que es posible que nos interese usar: podemos usarlos convirtiendo los datos de la estructura sf a sp. library(sf) censo &lt;- st_read(&quot;datos/Granada/municipios censo GR.shp&quot;) class(censo) summary(censo) hidro &lt;- st_read(&quot;datos/Granada/red hidrografica GR.shp&quot;) summary(hidro) censo_sp &lt;- as(censo, Class = &quot;Spatial&quot;) # funciones de sp. class(censo_sp) sp::summary(censo_sp) censo_sf &lt;- st_as_sf(censo_sp) class(censo_sf) summary(censo_sf) Mediante la función st_read() del paquete sf leemos una capa de la carpeta de trabajo. La función class() nos muestra que hemos leído un data frame. La función summary() nos muestra un resumen de las columnas del data frame. Las columnas son las mismas que muestra QGIS en la tabla de atributos pero, además, tenemos la columna geometry que es la que contiene los datos geográficos de la capa. Para representar solo la geometría de una capa, esta es la columna que debemos utilizar explícitamente. 3.3 Representar capas La función st_geometry() del paquete sf nos devuelve el componente geometry de una capa11. Representamos la capa mediante la función plot(). Al resultado podemos añadir otras capas mediante la misma función, pero utilizando el parámetro add para indicarlo. El resultado se muestra en la zona inferior derecha de la ventana, en la pestaña Plots. Podemos exportarlo a distintos formatos mediante la opción Export. plot(st_geometry(censo)) plot(st_geometry(hidro), col = &quot;blue&quot;, add = TRUE) 3.4 Cambiar el color y otros elementos de una capa Para cambiar la representación de una capa debemos representarla de nuevo. La función plot() ofrece muchas posibilidades, algunas de ellas se muestran a continuación: hemos cambiado el color, el grosor de las líneas y añadido ejes a la representación. plot(st_geometry(censo), col = &quot;lightgreen&quot;, lwd = 1.5, axes = TRUE) 3.5 Importar una imagen desde la Web Vamos a importar una imagen desde OpenStreetMap12. Hay un paquete R llamado OpenStreetMap que ofrece esta funcionalidad. library(OpenStreetMap) censo_cg &lt;- st_transform(censo, 4326) summary(censo_cg) # rectángulo más pequeño que incluye la capa sup_izq &lt;- as.vector(cbind(st_bbox(censo_cg)[&#39;ymax&#39;], st_bbox(censo_cg)[&#39;xmin&#39;])) inf_der &lt;- as.vector(cbind(st_bbox(censo_cg)[&#39;ymin&#39;], st_bbox(censo_cg)[&#39;xmax&#39;])) mapa_osm &lt;- openmap(sup_izq, inf_der, type = &quot;bing&quot;) censo_osm &lt;- st_transform(censo_cg, osm()) # restaurar el área de visualización graphics.off() plot(mapa_osm) plot(st_geometry(censo_osm), add = TRUE, lwd = 1.2) La función de OpenStreetMap que obtiene un mapa de una zona determinada es openmap(). Si miramos su definición, trabaja con la latitud y longitud. Deberemos transformar la capa que queramos representar a un CRS que permita obtener directamente estos datos: por ejemplo, el de código EPSG 4326. La transformación se puede llevar a cabo mediante la función st_transform(). A partir de esta representación de la capa, obtenemos los vértices del rectángulo más pequeño que la incluye. Con dos de esos vértices, mediante la función openmap() obtenemos el mapa de la Web, el tipo de mapa a importar se define mediante el parámetro type. Como vamos a representar el mapa obtenido conjuntamente con la capa de partida, vamos a transformar la capa para que tenga el mismo CRS que OpenStreetMap mediante las funciones st_transform(), que realiza la transformación, y osm(), que devuelve el CRS de OpenStreetMap. Figura 3.1: Ejemplo con una de las capas y una imagen de OpenStreetMap. En la figura 3.1, se muestra el resultado obtenido al presentar una de las capas con la capa obtenida de OpenStreetMap mediante el código de los ejemplos. Es recomendable usar esta función en lugar de acceder directamente al componente geometry del data frame porque el resultado obtenido con ambos métodos de acceso no siempre es idéntico.↩︎ https://www.openstreetmap.org↩︎ "],["explorar-una-capa.html", "4 Explorar una capa 4.1 Acceder a elementos de una capa 4.2 Tabla de atributos de una capa", " 4 Explorar una capa Si consultamos una capa mediante la función class(), podemos comprobar que es un data frame. Podemos acceder a esta estructura como se mostró con ejemplos en el apartado 2.3.2. 4.1 Acceder a elementos de una capa En el ejemplo siguiente, en primer lugar, se muestran los datos de un municipio (accediendo al data frame que almacena los datos); a continuación, se representa gráficamente, de la misma forma que representamos toda la capa; por último, se representan varios municipios seleccionados en el data frame. censo[censo$municipio == &quot;Lanjarón&quot;, ] plot(st_geometry(censo[censo$municipio == &quot;Lanjarón&quot;, ])) plot(st_geometry(censo[censo$municipio == &quot;Lanjarón&quot; | censo$municipio == &quot;Monachil&quot; | censo$municipio == &quot;Dúrcal&quot;| censo$municipio == &quot;Cáñar&quot;,])) plot(st_geometry(censo[censo$municipio %in% c(&quot;Lanjarón&quot;, &quot;Dilar&quot;, &quot;Dúrcal&quot;, &quot;Nigüelas&quot;, &quot;Cáñar&quot;, &quot;Bubión&quot;, &quot;Pampaneira&quot;, &quot;Soportújar&quot;, &quot;Capileira&quot;, &quot;Órjiva&quot;, &quot;Vélez de Benaudalla&quot;, &quot;El Pinar&quot;, &quot;Lecrín&quot;),])) 4.2 Tabla de atributos de una capa La tabla de atributos de una capa es un data frame (la capa tiene más componentes). Podemos comprobarlo al mostrar todos sus datos, como se hace en el ejemplo siguiente. Podemos acceder a los componentes de varias formas, aunque no son equivalentes: por ejemplo, si accedemos a una columna mediante censo$Ce2018M obtenemos solo los datos de la columna; si lo hacemos mediante censo[, 'Ce2018T'] obtenemos adicionalmente la columna geometry. También podemos seleccionar varias columnas o combinar la selección de filas y columnas. censo censo$Ce2018T censo[, &#39;Ce2018T&#39;] censo[, c(&#39;Ce2015T&#39;, &#39;Ce2018T&#39;)] censo[censo$municipio == &quot;Lanjarón&quot;, c(&#39;Ce2015T&#39;, &#39;Ce2018T&#39;)] "],["operaciones-sobre-la-tabla-de-atributos.html", "5 Operaciones sobre la tabla de atributos 5.1 Lectura de una tabla en un data frame 5.2 Añadir un campo a la tabla de atributos 5.3 Unir tablas de atributos 5.4 Consultas sobre la tabla de atributos 5.5 Guardar una capa", " 5 Operaciones sobre la tabla de atributos 5.1 Lectura de una tabla en un data frame Cada capa tiene su propia tabla de atributos pero también podemos tener solo tablas de atributos, sin elementos geométricos. A continuación, leemos la tabla con los datos del censo de los municipios de Granada para los últimos años. library(readxl) t &lt;- read_excel(&quot;datos/Granada/2871gr.xlsx&quot;, col_names = TRUE, trim_ws = TRUE) class(t) Como veremos a continuación, podemos trabajar con estos datos para combinarlos con otras capas. Para este caso en particular, nos interesará combinar los datos del censo actuales con los almacenados en la capa de municipios, que contiene los datos del censo desde 2014 a 2018 asociados a información geográfica de los municipios. 5.2 Añadir un campo a la tabla de atributos Se puede modificar la tabla de atributos de cualquier capa. Una de las modificaciones más frecuentes es añadir un campo nuevo definido a partir de otros campos. En este ejemplo, vamos a modificar la tabla de atributos de la capa que solo contiene esa tabla. Todas las tablas de atributos se modifican de la misma forma. Añadir un campo a la tabla de atributos equivale a definir una nueva columna en un data frame: definimos el nombre de la nueva columna junto con la expresión para obtener sus valores. t$Codigo &lt;- substr(t$Municipios, 1, 5) t[, &#39;Codigo&#39;] 5.3 Unir tablas de atributos Para unir dos tablas de atributos, estas deben compartir algún campo con valores en común, los nombres de los campos utilizados para definir la unión no es relevante. La unión la realizamos mediante la función merge(). A la vista del resultado, podemos eliminar las columnas redundantes, en este caso, la columna Municipio, y, aunque no sea relevante el orden de las columnas en un data frame, podemos reordenar las columnas. Mediante la función dput() generamos el vector de nombres de columnas del data frame, utilizamos esa estructura para incluir solo las columnas que deseemos y reordenarlas si lo consideramos conveniente. censo &lt;- merge(x = censo, y = t, by.x = &quot;cod_mun&quot;, by.y = &quot;Codigo&quot;, all.x = TRUE) censo dput(names(censo)) censo &lt;- censo[, c(&quot;cod_mun&quot;, &quot;municipio&quot;, &quot;provincia&quot;, &quot;cod_ent&quot;, &quot;shape_leng&quot;, &quot;shape_area&quot;, &quot;Superficie&quot;, &quot;Ce2014T&quot;, &quot;Ce2014H&quot;, &quot;Ce2014M&quot;, &quot;Ce2015T&quot;, &quot;Ce2015H&quot;, &quot;Ce2015M&quot;, &quot;Ce2016T&quot;, &quot;Ce2016H&quot;, &quot;Ce2016M&quot;, &quot;Ce2017T&quot;, &quot;Ce2017H&quot;, &quot;Ce2017M&quot;, &quot;Ce2018T&quot;, &quot;Ce2018H&quot;, &quot;Ce2018M&quot;, &quot;Ce2019T&quot;, &quot;Ce2019H&quot;, &quot;Ce2019M&quot;, &quot;Ce2020T&quot;, &quot;Ce2020H&quot;, &quot;Ce2020M&quot;, &quot;Ce2021T&quot;, &quot;Ce2021H&quot;, &quot;Ce2021M&quot;, &quot;Ce2022T&quot;, &quot;Ce2022H&quot;, &quot;Ce2022M&quot;, &quot;Ce2023T&quot;, &quot;Ce2023H&quot;, &quot;Ce2023M&quot;)] censo 5.4 Consultas sobre la tabla de atributos Supongamos que queremos seleccionar los municipios cuya población haya aumentado durante el último año. Podemos definir consultas de filtrado de filas sobre la tabla de atributos de una capa: son operaciones de filtrado sobre un data frame. En el ejemplo siguiente, definimos el filtrado directamente y también definiendo un nuevo campo y, a continuación, definir el filtrado sobre él. censo[(censo$Ce2023T - censo$Ce2022T) &gt; 0, ] censo$Incremento &lt;- censo$Ce2023T - censo$Ce2022T censo[censo$Incremento &gt; 0, ] 5.5 Guardar una capa Para guardar una capa en un archivo, indicamos la variable que contiene la capa y el archivo donde queremos que se guarde, como se muestra en el ejemplo siguiente. Según la extensión del archivo la función st_write() determina el formato a utilizar para almacenar los datos. El parámetro delete_dsn permite sobreescribir un archivo previamente guardado. st_write(obj = censo, dsn = &quot;datos/Granada/municipios censo GR jsamos.shp&quot;, delete_dsn = TRUE) "],["añadir-elementos-a-la-representación-las-de-capas.html", "6 Añadir elementos a la representación las de capas 6.1 Mostrar etiquetas 6.2 Representar información numérica", " 6 Añadir elementos a la representación las de capas Se puede representar en una capa el valor de cualquier columna de la tabla de atributos. En particular, vamos a representar mediante etiquetas los nombres de los municipios y, creando un mapa de coropletas, un valor numérico. 6.1 Mostrar etiquetas Las etiquetas las mostramos a continuación mediante la función text(). A esta función le tenemos que indicar, para cada fila, la posición donde escribir el texto y el campo que contiene el texto a escribir. Para determinar automáticamente las coordenadas, utilizamos la función st_centroid() que devuelve el centroide de la representación de cada municipio; a partir del centoide, mediante la función st_coordinates() se obtienen sus coordenadas. El texto que se representa es el contenido en el campo municipio. Mediante el resto de parámetros se indica la posición relativa del texto respecto a centroide y su tamaño. seleccion &lt;- &quot;Lanjarón&quot; municipio_sel &lt;- censo[censo$municipio == seleccion,] plot(st_geometry(censo), axes = TRUE, main = seleccion) plot(st_geometry(municipio_sel), col = &quot;lightgreen&quot;, add = TRUE) text( st_coordinates(st_centroid(st_geometry(censo))), labels = censo$municipio, pos = 3, cex = 0.5 ) A continuación, se muestra una forma alternativa de obtener un mapa con las etiquetas de los nombres; en este caso, mediante las funciones del paquete tmap. En la primera línea, mediante la función tm_shape(), se indica qué se quiere representar; en las líneas siguientes, se incluyen más detalles o más datos de la representación13. En este caso, no se puede ejecutar línea a línea sino que se ejecuta conjuntamente como un todo. library(tmap) tm_shape(censo) + tm_fill(&quot;white&quot;) + tm_borders() + tm_text(&quot;municipio&quot;, size = 0.3) + tm_shape(municipio_sel) + tm_fill(&quot;lightgreen&quot;) + tm_borders(lwd = 2) + tm_text(&quot;municipio&quot;, size = 0.3) + tm_layout( frame = FALSE, title = seleccion, title.size = 1, title.position = c(0.5, &quot;top&quot;) ) 6.2 Representar información numérica La función plot() representa directamente información numérica en forma de mapa de coropletas, basta con indicar explícitamente el campo de la tabla de atributos a utilizar en la representación, como se muestra a continuación. plot(censo[, &quot;Incremento&quot;], main = &quot;Granada&quot;) A continuación, se muestra cómo obtener un resultado similar al anterior pero con el paquete tmap. tm_shape(censo) + tm_fill(&quot;Incremento&quot;) + tm_borders() + tm_layout(frame = FALSE, title = &quot;Granada&quot;, title.size = 1, title.position = c(0.35, &quot;top&quot;)) Esta es una manera de componer funciones que ofrece el paquete magrittr (https://magrittr.tidyverse.org/).↩︎ "],["generar-la-salida-del-proyecto.html", "7 Generar la salida del proyecto 7.1 Guardar como una imagen 7.2 Imprimir un mapa 7.3 Generar un mapa para la Web", " 7 Generar la salida del proyecto En los apartados siguientes se va a generar la salida del proyecto usando el paquete tmap. Para generar una imagen o un mapa también se puede usar el paquete sf. En todos los casos funciona igual: se redirige la salida al tipo que se desee, se genera el mapa mediante las funciones necesarias y, cuando se haya acabado, se desactiva la salida para que se guarden los cambios. 7.1 Guardar como una imagen En el ejemplo siguiente, se muestra cómo generar un archivo png (hay funciones similares para otros formatos gráficos, por ejemplo jpg()). En la función png() se pueden usar parámetros para indicar diversas características de la imagen que se genera. El proceso de generación se acaba al ejecutar la función dev.off(), entonces se guarda el archivo en la carpeta de trabajo. png(&quot;selección.png&quot;) tm_shape(censo) + tm_fill(&quot;white&quot;) + tm_borders() + tm_text(&quot;municipio&quot;, size = 0.3) + tm_shape(municipio_sel) + tm_fill(&quot;lightgreen&quot;) + tm_borders(lwd = 2) + tm_text(&quot;municipio&quot;, size = 0.3) + tm_layout( frame = FALSE, title = seleccion, title.size = 1, title.position = c(0.5, &quot;top&quot;) ) dev.off() 7.2 Imprimir un mapa A un mapa le podemos añadir el título, la escala, la flecha del norte, entre otros elementos. Podemos guardarlo como un gráfico o como un archivo en formato PDF, como se hace en el ejemplo siguiente. En las pruebas que he hecho, la resolución es mucho mejor en formato PDF que en cualquier formato gráfico, por eso se usa este formato. pdf(&quot;selección.pdf&quot;) tm_shape(censo) + tm_fill(&quot;Incremento&quot;) + tm_borders() + tm_text(&quot;municipio&quot;, size = 0.3) + tm_layout( frame = FALSE, title = &quot;Granada&quot;, title.size = 1, title.position = c(0.35, &quot;top&quot;) ) + tm_compass(type = &quot;8star&quot;, position = c(&quot;right&quot;, &quot;bottom&quot;)) + tm_scale_bar( breaks = c(0, 25, 50), text.size = 0.5, position = c(&quot;right&quot;, &quot;bottom&quot;) ) dev.off() 7.3 Generar un mapa para la Web Podemos generar un mapa para la Web usando funciones del paquete tmap. Funciona igual que para la generación de un archivo gráfico o en formato PDF: en este caso se usa la función tmap_mode() para indicar el inicio y el final del proceso de generación. En este caso, la generación se ha de llevar a cabo mediante funciones del propio paquete. tmap_mode(&#39;view&#39;) tm_shape(censo) + tm_fill(alpha = 0) + tm_borders() + tm_text(&quot;municipio&quot;, size = 0.5) + tm_shape(municipio_sel) + tm_fill(&quot;lightgreen&quot;) + tm_borders(lwd = 2) + tm_text(&quot;municipio&quot;, size = 0.5) + tm_layout( frame = FALSE, title = seleccion, title.size = 1, title.position = c(0.35, &quot;top&quot;) ) tmap_mode(&#39;plot&#39;) Figura 7.1: Guardar el resultado como una página Web en el disco local. Nos permite guardar el resultado como una página Web local (figura 7.1), que podemos abrir con nuestro navegador. "],["ejercicios.html", "Ejercicios", " Ejercicios Realiza los ejercicios y entrega un solo documento en formato PDF en la tarea correspondiente de PRADO. Ejercicio. Ejemplos de código Ejecuta los fragmentos de código del apartado 2 y trata de entender cómo se producen los resultados que se obtienen. No es necesario documentar la realización de este ejercicio. Ejercicio. Datos de Granada Descarga de https://doi.org/10.6084/m9.figshare.11295644: El archivo Granada.zip que contiene los archivos de las capas que se usarán como fuente de datos en formato Shapefile. El archivo actualiza censo GR 202X.zip que contiene las actualizaciones del censo de los municipios de Granada disponibles en el año 202X en dos formatos, CSV y Excel. Extrae todos archivos y sitúalos en una carpeta de trabajo. No es necesario documentar la realización de este apartado. Ejercicio 1. Representación inicial Representa las capas de la provincia de Granada facilitadas junto a una capa obtenida de la Web (distinta a la utilizada en esta actividad). Define colores adecuados para los elementos representados en las capas. Para documentar la realización del ejercicio, captura una pantalla completa de RStudio donde se muestre el último código ejecutado y el resultado obtenido en la ventana Viewer. Ejercicio 2. Actualizar datos del censo Para la capa de municipios, actualiza la tabla de atributos con los datos del censo para los últimos años disponibles (los posteriores a 2018). Una vez actualizada la tabla de atributos, define un campo llamado tpc_inc_202X (sustituyendo ‘X’ por el dígito correspondiente al último año del que hay datos) como el porcentaje de incremento de población en el último año respecto al año anterior. Define un filtro que seleccione los municipios que hayan disminuido su población en el último año. Guarda la capa con todas las filas como un GeoPackage cuyo nombre incluya tu nombre de usuario de correo. Guarda la capa filtrada como un Shapefile cuyo nombre incluya tu nombre de usuario de correo y la palabra “filtro”. Para documentar la realización del ejercicio, incluye el código R desarrollado y captura una pantalla completa de RStudio donde se muestre la tabla de atributos de cada una de las capas guardadas y se vean los nuevos campos añadidos. Se puede ver la tabla mediante la función View(). Ejercicio 3. Etiquetas y simbología Para la capa de municipios, una vez actualizada con los datos del censo: Representa el mapa mediante coropletas basadas en el campo definido en el ejercicio anterior para todos los municipios de la provincia. Define etiquetas para alguna de las capas. Para documentar la realización del ejercicio, incluye el código R desarrollado y captura una pantalla donde se muestre el resultado. Ejercicio 4. Resultado del proyecto Genera una composición de impresión cuyo nombre sea tu nombre de usuario de correo, basada en el proyecto, que incluya el mapa de coropletas del ejercicio anterior, título, escala, leyenda y flecha del norte. Genera un mapa para la Web a partir del proyecto. Para documentar la realización del ejercicio, incluye el código R desarrollado y captura las pantallas donde se muestren los resultados. "],["referencias.html", "Referencias", " Referencias Brundsdon, Chris, and Lex Comber. 2019. An Introduction to R for Spatial Analysis &amp; Mapping. 2nd ed. SAGE. Lovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019. Geocomputarion with R. 2nd ed. CRC Press. https://r.geocompx.org/. Matloff, Norman. 2011. The Art of R Programming: A Tour of Statistical Software Design. no starch press. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
